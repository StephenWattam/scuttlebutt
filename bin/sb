#!/usr/bin/env ruby
#
#
# Scuttlebutt main executable
#
# 
#

# -----------------------------------------------------------------------------
# Config

DEFAULT_BROWSER = :firefox

# -----------------------------------------------------------------------------
# Procedures

# Check a file is existent and readable.
def check_file(filename)
  if !File.exist?(filename)
    $stderr.puts "File does not exist: #{filename}"
    exit(1)
  elsif !File.readable?(filename)
    $stderr.puts "File is not readable: #{filename}"
    exit(1)
  end
end




# -----------------------------------------------------------------------------
# Print usage if no argument is given
if ARGV.length < 3
  $stderr.puts "USAGE: #{$PROGRAM_NAME} SCRIPT URL_LIST OUTPUT_FILE\n"
  $stderr.puts "\nWhere SCRIPT is a Scuttlebutt script"
  $stderr.puts "      URL_LIST is a CSV containing data for scraping"
  $stderr.puts "      OUTPUT_FILE is a filepath for CSV output."
  exit(1)
end

check_file(ARGV[0])
check_file(ARGV[1])


# -----------------------------------------------------------------------------
# Load libraries and gems
require 'scuttlebutt'
include Scuttlebutt


# -----------------------------------------------------------------------------
# Configure logs
LOG.add_log( :default, STDOUT, UI::MultiOutputLogger.string_to_level('info') )
LOG.add_log( :debug,   "debug.log", UI::MultiOutputLogger.string_to_level('debug') )
LOG.formatter = proc do |severity, datetime, progname, msg|
  "#{severity.to_s[0]} #{datetime}: #{msg}\n"
end


# -----------------------------------------------------------------------------
# Load resources from files


begin

  # Read the script from disk
  script = ScriptCompiler.compile(ARGV[0])
  LOG.info "Script read from #{script.filename}"
  LOG.info "Script written by #{script.params.author.join(', ')}" if script.params.author
  LOG.info "Contact details: #{script.params.email.join(', ')}" if script.params.author

  # Create input/output objects and check against script
  input  = Input::CSVSource.new(ARGV[1])
  output = script.params.output_fields ? Output::CSVOutput.new(ARGV[2], script.params.output_fields) : Output::CachedCSVOutput.new(ARGV[2])

  script.check_input(input)
  script.check_output(output)

  # Apply engine options from the script
  browser = DEFAULT_BROWSER
  browser = script.params.browser.first.to_sym if script.params.browser
  engine = Engine.new(browser)

  # Create the execution context
  vm     = VirtualMachine.new(input, output, engine)

  # -----------------------------------------------------------------------------
  # Begin main loop


  # Run the process, using the callback to update the spinner
  vm.run(script)


  # Close input CSV
  input.close

rescue StandardError => e
  LOG.fatal "Fatal error: #{e}"
  LOG.debug "#{e.backtrace.join("\n")}"

ensure
  engine.close if engine

  if output
    LOG.info "Output has #{output.cached_data} items waiting to write to disk..."
    output.flush
    output.close
  end
end

