# vim: syntax=ruby

# Reads a comment thread
def read_thread(id)
    status "Reading thread #{id}..."

    # Return if the id is not set (this occasionally happens due to a
    # placeholder the Guardian set on their page
    return if id == ""

    # Using Xpath, extract fun data
    comment_data = find_comment_data(id)

    # Find replies, and look them all up
    replies   = @e.find_elements(:css, "li##{id} ul.d2-responses li, li##{id} ul.d2-responses div#d2-collapse-wrap li")
    replies.map! { |el| el.attribute("id") }

    status "Found #{replies.length} replies."

    reply_data = []
    replies.each do |reply_id|
        reply_data << find_comment_data(reply_id)
    end

    return comment_data, reply_data
end


def find_comment_data(id)
    return if id.to_s.length == 0

    status "Mining comment #{id}..."

    element_path = "li##{id} div.d2-comment-inner"
    cpath = element_path + " div.d2-right-col"

    id        = id
    picpath   = @e.find_element(:css, "#{element_path} div.d2-left-col a img").attribute("src")
    username  = @e.find_element(:css, "#{cpath} a.d2-username").text
    userpage  = @e.find_element(:css, "#{cpath} a.d2-username").attribute("href")
    permalink = @e.find_element(:css, "#{cpath} div.d2-permalink p.d2-datetime a").attribute("href")
    body      = @e.find_element(:css, "#{cpath} div.d2-body").text
    rec_count = try(0){ @e.find_element(:css, "#{cpath} div.d2-js-recommender div.d2-recommend-count b").text.to_i }
    reply_to  = try(0){ @e.find_element(:css, "#{cpath} div.d2-in-reply-to a").attribute("href")[1..-1] }


    # status "found comment by #{username}, permalink: #{permalink}"

    return {}
end


# ---------------------------------------------------------------------------
##= read_comment_data
# ---------------------------------------------------------------------------

top_level_comments = @e.find_elements(:css => "ul.d2-comments li.d2-comment")
        # :xpath => "//ul[@class='d2-comments']/li[@class='d2-comment']")
top_level_comments.map! { |el| el.attribute("id").strip }
top_level_comments.delete(nil)



status "Found #{top_level_comments.length} threads..."


top_level_comments.each do |element|
    read_thread(element)
end



# ---------------------------------------------------------------------------
##= read_then_click_next
# ---------------------------------------------------------------------------

# Read comment data from the current page
read_comment_data

status "Moving to next page..."

# Find the "next" button
next_link = try{ @e.find_element(:css, "div.d2-next-page a") }


if next_link

    # Follow the link
    next_link.click

    # Allow the AJAX to catch up
    Time.delay(3)

    # Read more data from the next page
    read_then_click_next
end


# ---------------------------------------------------------------------------
##= r3
# ---------------------------------------------------------------------------

status "Region 3"

# ---------------------------------------------------------------------------
##= system_up
# ---------------------------------------------------------------------------
status "System up"


# ---------------------------------------------------------------------------
##= row_up
# ---------------------------------------------------------------------------

status "Locating comment section..."

# Load the article
@e.get(field('url'))

# Find the source of the iframe
iframe = @e.find_element("name" => "d2-iframe")
comment_url = iframe.attribute("src")





status "Selecting comment page..."

# Load the iframe contents
@e.get(comment_url)


# Select "All comments" if not already
try{
    all_comments_link = @e.find_element(:link_text => "All comments")
    @e.get(all_comments_link.attribute("href"))
}


# Show threads in "expanded" mode
# /html/body/div/div[3]/form/div/span[2]/span/select
select = @e.find_element(:name => "threads")
options = select.find_elements(:tag_name, "option")
options.each{|o| 
    o.click if o.attribute("value") =~ /expanded/i
}
select.submit


read_then_click_next



# ---------------------------------------------------------------------------
##= row_down
# ---------------------------------------------------------------------------

status "Row down"

# ---------------------------------------------------------------------------
##= system_down
# ---------------------------------------------------------------------------

status "System [of a] down."
